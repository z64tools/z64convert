/* world-header.h: for quickly adding scene/room headers to certain output files */

#ifndef WORLD_HEADER_H_INCLUDED
#define WORLD_HEADER_H_INCLUDED 1

#include <stdio.h>
#include <stdlib.h>

#define WORLD_HEADER_ERR "--world-header fail: "
#define WORLD_HEADER_SCENE_HEADER_LENGTH 0x120
#define WORLD_HEADER_ROOM_HEADER_LENGTH 0x40

#define S16_BYTES(X) ((((short int)(X)) >> 8) & 0xff), ((X) & 0xff)
#define U24_BYTES(X) (((X) >> 16) & 0xff), (((X) >> 8) & 0xff), ((X) & 0xff)

static struct WorldHeader
{
	struct
	{
		float x;
		float y;
		float z;
	} playerSpawnAt;
	int isEnabled;
	int roomNum;
} sgWorldHeader = {0};

// Basic room header
static void worldHeaderWriteRoom(VFILE *dst, struct objex *obj)
{
	unsigned int fileEnd = vftell(dst);
	unsigned int meshHeader = fileEnd;
	struct objex_g **opa = 0;
	struct objex_g **xlu = 0;
	int opaNum = 0;
	int xluNum = 0;
	int opaNow = 0;
	int xluNow = 0;
	unsigned int baseOfs = 0x03000000;
	
	if (!sgWorldHeader.isEnabled)
		return;

	unsigned char rawData[WORLD_HEADER_ROOM_HEADER_LENGTH] = {
		0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x10, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0A, 0x00,
		0x0A, 0x00, 0x00, 0x00,	0x03, U24_BYTES(meshHeader),
		0x05, 0x00, 0x00, 0x00, 0x0F, 0x28, 0x6D, 0xBE,
		0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00
	};
	
	vfseek(dst, 0, SEEK_SET);
	vfwrite(rawData, 1, sizeof(rawData), dst);
	vfseek(dst, 0, SEEK_END);
	
	/* display lists: count */
	for (struct objex_g *g = obj->g; g; g = g->next)
	{
		struct groupUdata *ud = g->udata;
		
		if (!ud || !ud->hasWritten || g->isCollisionAddr)
			continue;
		
		/* assuming everything uses opa for now */
		opaNum += 1;
	}
	
	/* display lists: populate */
	opa = calloc(opaNum, sizeof(*opa));
	opaNow = 0;
	for (struct objex_g *g = obj->g; g; g = g->next)
	{
		struct groupUdata *ud = g->udata;
		
		if (!ud || !ud->hasWritten || g->isCollisionAddr)
			continue;
		
		opa[opaNow] = g;
		opaNow += 1;
	}
	
	// write mesh header
	vfput8(dst, 0x02); // type 2
	vfput8(dst, opaNum); // number of entries
	vfput16(dst, 0); // padding
	vfput32(dst, baseOfs + meshHeader + 12); // start entries
	vfput32(dst, baseOfs + meshHeader + 12 + opaNum * 16); // end of entries
	
	for (int i = 0; i < opaNum; ++i)
	{
		struct objex_g *g = opa[i];
		struct groupUdata *ud = g->udata;
		unsigned int addr = baseOfs + ud->dlistOffset;
		float x;
		float y;
		float z;
		float radius;
		
		objex_g_get_center_radius(g, &x, &y, &z, &radius);
		
		vfput16(dst, (short)x);
		vfput16(dst, (short)y);
		vfput16(dst, (short)z);
		vfput16(dst, radius);
		vfput32(dst, addr); // opa
		vfput32(dst, 0); // xlu
	}
	
	if (opa)
		free(opa);
	if (xlu)
		free(xlu);

}

// Basic scene header
static void worldHeaderWriteScene(VFILE *dst, struct objex *obj, unsigned int baseOfs, unsigned int collHeader, float scale)
{
	short int x = sgWorldHeader.playerSpawnAt.x * scale;
	short int y = sgWorldHeader.playerSpawnAt.y * scale;
	short int z = sgWorldHeader.playerSpawnAt.z * scale;
	unsigned int fileEnd = vftell(dst);
	unsigned int roomList = fileEnd;
	int roomNum = sgWorldHeader.roomNum;
	
	if (!sgWorldHeader.isEnabled)
		return;

	unsigned char rawData[WORLD_HEADER_SCENE_HEADER_LENGTH] = {
		0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
		0x04, roomNum, 0x00, 0x00, 0x02, U24_BYTES(roomList),
		0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x02, U24_BYTES(collHeader),
		0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x18,
		0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x58,
		0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0F, 0x08, 0x00, 0x00, 0x02, 0x00, 0x00, 0x68,
		0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, S16_BYTES(x), S16_BYTES(y), S16_BYTES(z),
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF,
		0x46, 0x2D, 0x39, 0x49,	0x49, 0x49, 0xB4, 0x9A,
		0x8A, 0xB7, 0xB7, 0xB7, 0x14, 0x14, 0x3C, 0x8C,
		0x78, 0x6E, 0x07, 0xE1, 0x32, 0x00, 0x69, 0x5A,
		0x5A, 0x49, 0x49, 0x49,	0xFF, 0xFF, 0xF0, 0xB7,
		0xB7, 0xB7, 0x32, 0x32, 0x5A, 0x64, 0x64, 0x78,
		0x07, 0xE4, 0x32, 0x00, 0x78, 0x5A, 0x00, 0x49,
		0x49, 0x49, 0xFA, 0x87,	0x32, 0xB7, 0xB7, 0xB7,
		0x1E, 0x1E, 0x3C, 0x78, 0x46, 0x32, 0x07, 0xE3,
		0x32, 0x00, 0x28, 0x46, 0x64, 0x49, 0x49, 0x49,
		0x14, 0x14, 0x23, 0xB7,	0xB7, 0xB7, 0x32, 0x32,
		0x64, 0x00, 0x00, 0x1E, 0x07, 0xE0, 0x32, 0x00,
		0x3C, 0x28, 0x46, 0x49, 0x49, 0x49, 0x50, 0x1E,
		0x3C, 0xB7, 0xB7, 0xB7,	0x50, 0x32, 0x96, 0x46,
		0x2B, 0x2D, 0xFF, 0xD2, 0x32, 0x00, 0x4B, 0x5A,
		0x64, 0x49, 0x49, 0x49, 0x37, 0xFF, 0xF0, 0xB7,
		0xB7, 0xB7, 0x0A, 0x96,	0xBE, 0x14, 0x5A, 0x6E,
		0xFF, 0xD2, 0x32, 0x00, 0x3C, 0x28, 0x50, 0x49,
		0x49, 0x49, 0x3C, 0x4B, 0x96, 0xB7, 0xB7, 0xB7,
		0x3C, 0x37, 0x96, 0x32,	0x1E, 0x1E, 0xFF, 0xD2,
		0x32, 0x00, 0x00, 0x28, 0x50, 0x49, 0x49, 0x49,
		0x14, 0x32, 0x4B, 0xB7, 0xB7, 0xB7, 0x32, 0x64,
		0x96, 0x00, 0x0A, 0x14,	0xFF, 0xD2, 0x32, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	vfseek(dst, 0, SEEK_SET);
	vfwrite(rawData, 1, sizeof(rawData), dst);
	vfseek(dst, 0, SEEK_END);
	
	for (int i = 0; i < roomNum * 8; ++i)
		vfput8(dst, 0);
}

static const char *worldHeaderSetup(const char *input)
{
	float x;
	float y;
	float z;
	
	if (!input || !*input)
		return WORLD_HEADER_ERR "no input string";
	
	if (sscanf(input, "%f,%f,%f", &x, &y, &z) != 3)
		return WORLD_HEADER_ERR "not in 'x,y,z' format";
	
	sgWorldHeader.playerSpawnAt.x = x;
	sgWorldHeader.playerSpawnAt.y = y;
	sgWorldHeader.playerSpawnAt.z = z;
	
	sgWorldHeader.isEnabled = 1;
	
	return 0;
}

#endif /* WORLD_HEADER_H_INCLUDED */

